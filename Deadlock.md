#**LAB4 死锁**

##**姓名:洪哲铮 学号:14353085 班级:14M1**  
<br/>
#一、截图
#正常停止：
![image](https://cl.ly/312x1q283h2v/normal.png)
#死锁：
![image](https://cl.ly/282b3U0c1L2M/Dead.png)
#二、产生死锁的四个必要条件

<font size=5>（1） 互斥条件：一个资源每次只能被一个进程使用。</font><br>
<font size=5>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</font><br>
<font size=5>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</font><br>
<font size=5>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</font><br>

##三、对上述程序产生死锁的解释
<font size=5>在上述实验中，我们定义了两个类（A和B），他们分别包含了一种调用另一个类中方法last（）的方法，这就造成了一种互斥条件，两个进程互相请求对方占有的资源。一个进程因请求资源而阻塞时，对已获得的资源保持不放，就导致了进程之间形成一种头尾相接的循环等待资源关系，也就是我们常说的“死锁”。在这道题中，我们是通过修改count的值来实现死锁的。count这一个变量代表的是线程等待的时间，我们通过增大count的值，增加线程等待的时间，让其他线程有更多机会来申请这个资源，就更容易造成死锁的现象，正如我们运行bat文件后观察到一样。（见上方截图）</font><br>


